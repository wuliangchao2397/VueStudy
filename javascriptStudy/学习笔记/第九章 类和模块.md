# 第九章 类和模块

## 概念

* 可以定义对象的类，让每个对象共享某些属性
* 类的实现是基于其原型继承机制的
* 类的一个重要特性“动态可继承”

## 1、类和原型

* 类的所有实例对象都从同一个原型上继承属性，原型对象是类的核心
* 类的创建其实就是通过inherit（）从对象原型继承而来
* 通常类的实例需要初始化继承自原型的对象
* 任何类的方法都可以通过this这个基本用法来读取对象的属性

## 2、类和构造函数

* 概念：
  * 同一个构造函数创建的所有对象都继承自一个相同的对象，它们都是同一个类的成员
  * 注意原型对象的命名，构造函数会调用其prototype作为原型，Range.prototype是一种强制性的命名
* 1、构造函数和类的标识
  * 原型对象是类的唯一标识，初始化对象的状态的构造函数不能作为类的标识
  * 构造函数的名字常用作类名
  * instanceof不会检查是否是某个构造函数初始化而来，但是会检查对象是否是继承自该构造函数的prototype
* 2、constructor属性
  * 除了bind（）返回的函数，都拥有一个prototype属性，这个属性的值是一个对象，这个对象包含一个不可枚举的属性constructor，其值也是一个对象
  * 对象继承的constructor通常指代它们的构造函数，这个constructor属性为对象提供了类
  * 被重定义过的prototype对象如果没有写入constructor，就不会有constructor属性，需要显式添加构造函数
  * 另一种解决重定义的prototype没有constructor属性的方法，是通过扩展使用预定义的原型对象不重写它，这样就能就会自动生成constructor

## 3、JavaScript中Java的类继承

* JavaScript与Java最主要的一个区别就是JavaScript的函数都是以值的形式出现的，方法和字段之间没有太大的区别
* JavaScript的类牵扯三个不同的对象
  * 构造函数对象
  * 原型对象
  * 实例对象
* 定义类的步骤分为三步：先定义构造函数，设置初始化新对象的实例属性；给构造函数的prototype对象定义实例的方法；给构造函数定义类字段和类属性；一起封装进defineClass（）函数中
* JavaScript虽然可以模拟Java的类成员，但是很多特性是无法模拟的
* 可以使用final声明字段为常量，也可以声明为private

## 4、类的扩充

* JavaScript中原型继承机制是动态的，可以给原型对象添加方法来扩充JavaScript类
* 可以给Object.prototype添加新方法，ECMAScript5之前是不能被设置为不可枚举的，可以被for/in循环遍历找到
* 用Object.defineProperty（）安全的扩充Object.prototype，但也不是所有的宿主环境都能使用这个方法，需要注意

## 5、类和类型

* 三种检测任意对象的类的技术：instanceof、constructor、构造函数的名字
* 1、instanceof运算符
  * 左操作数是待检测的对象，右操作数是定义类的构造函数
  * 如果o继承自c.prototype，则返回true，只要能在原型链上找到即可返回true
  * isPrototypeOf（）可以用来检测对象是否存在于某个对象的原型链上
  * instanceof和IsPrototypeOf（）的缺点是不能通过对象获得名字，只能确定是否属于
* 2、constructor属性
  * 不足之处和instanceof一样，当拥有多个执行上下文场景它是无法正常工作的
* 3、构造函数名称
  * 可以解决前两种情况的缺点，不同窗口的构造函数不一样，但名字是可以一样的，通过GetName获取名字来对比
  * 这种方法同样会遇到问题，并不是所有的对象都有constructor属性，并不是所有的函数都有名字，会导致GetName（）获得空字符串
* 4、鸭式辩型
  * 规避这些问题，不关注“对象的类是什么”而是“对象能做什么”，即为“鸭式辩型”
  * Range（）函数确定范围，includes（）可以用作任何结束点
  * 但这种类型也需要注意，如果没遵循“假设”情况就会出现问题，另一种方法是通过适当的名字进行检查，不检查类

