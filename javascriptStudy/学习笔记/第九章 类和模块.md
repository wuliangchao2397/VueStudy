# 第九章 类和模块

## 概念

* 可以定义对象的类，让每个对象共享某些属性
* 类的实现是基于其原型继承机制的
* 类的一个重要特性“动态可继承”

## 1、类和原型

* 类的所有实例对象都从同一个原型上继承属性，原型对象是类的核心
* 类的创建其实就是通过inherit（）从对象原型继承而来
* 通常类的实例需要初始化继承自原型的对象
* 任何类的方法都可以通过this这个基本用法来读取对象的属性

## 2、类和构造函数

* 概念：
  * 同一个构造函数创建的所有对象都继承自一个相同的对象，它们都是同一个类的成员
  * 注意原型对象的命名，构造函数会调用其prototype作为原型，Range.prototype是一种强制性的命名
* 1、构造函数和类的标识
  * 原型对象是类的唯一标识，初始化对象的状态的构造函数不能作为类的标识
  * 构造函数的名字常用作类名
  * instanceof不会检查是否是某个构造函数初始化而来，但是会检查对象是否是继承自该构造函数的prototype
* 2、constructor属性
  * 除了bind（）返回的函数，都拥有一个prototype属性，这个属性的值是一个对象，这个对象包含一个不可枚举的属性constructor，其值也是一个对象
  * 对象继承的constructor通常指代它们的构造函数，这个constructor属性为对象提供了类
  * 被重定义过的prototype对象如果没有写入constructor，就不会有constructor属性，需要显式添加构造函数
  * 另一种解决重定义的prototype没有constructor属性的方法，是通过扩展使用预定义的原型对象不重写它，这样就能就会自动生成constructor

## 3、JavaScript中Java的类继承

* JavaScript与Java最主要的一个区别就是JavaScript的函数都是以值的形式出现的，方法和字段之间没有太大的区别
* JavaScript的类牵扯三个不同的对象
  * 构造函数对象
  * 原型对象
  * 实例对象
* 定义类的步骤分为三步：先定义构造函数，设置初始化新对象的实例属性；给构造函数的prototype对象定义实例的方法；给构造函数定义类字段和类属性；一起封装进defineClass（）函数中
* JavaScript虽然可以模拟Java的类成员，但是很多特性是无法模拟的
* 可以使用final声明字段为常量，也可以声明为private

## 4、类的扩充

* JavaScript中原型继承机制是动态的，可以给原型对象添加方法来扩充JavaScript类
* 可以给Object.prototype添加新方法，ECMAScript5之前是不能被设置为不可枚举的，可以被for/in循环遍历找到
* 用Object.defineProperty（）安全的扩充Object.prototype，但也不是所有的宿主环境都能使用这个方法，需要注意

## 5、类和类型

* 三种检测任意对象的类的技术：instanceof、constructor、构造函数的名字
* 1、instanceof运算符
  * 左操作数是待检测的对象，右操作数是定义类的构造函数
  * 如果o继承自c.prototype，则返回true，只要能在原型链上找到即可返回true
  * isPrototypeOf（）可以用来检测对象是否存在于某个对象的原型链上
  * instanceof和IsPrototypeOf（）的缺点是不能通过对象获得名字，只能确定是否属于
* 2、constructor属性
  * 不足之处和instanceof一样，当拥有多个执行上下文场景它是无法正常工作的
* 3、构造函数名称
  * 可以解决前两种情况的缺点，不同窗口的构造函数不一样，但名字是可以一样的，通过GetName获取名字来对比
  * 这种方法同样会遇到问题，并不是所有的对象都有constructor属性，并不是所有的函数都有名字，会导致GetName（）获得空字符串
* 4、鸭式辩型
  * 规避这些问题，不关注“对象的类是什么”而是“对象能做什么”，即为“鸭式辩型”
  * Range（）函数确定范围，includes（）可以用作任何结束点
  * 但这种类型也需要注意，如果没遵循“假设”情况就会出现问题，另一种方法是通过适当的名字进行检查，不检查类

## 6、JavaScript中的面向对象技术

* 1、集合类
  * set，非重复值的无序集合
  * 基础方法包括添加值、检测值是否在集合中，为保证效率，需要通用的实现
  * 对象就是属性名与之对应的值的基本集合
  * 集合类必须给每一个对象或函数定义一个唯一的属性标识
* 2、枚举类型
  * enumerated type，值的有限集合
  * Enum在ECMAScript5中是保留字，c及其派生语言中，枚举类型通过enum关键字声明
* 3、标准转换方法
  * 有一些方法是在需要做类型转换时由JavaScript解释器自动调用的。如果没有自定义实现这些，也应当注意设置
  * 最重要的就是toString（），返回一个可以表示这个对象的字符串，如果这个对象没有，就会从原型链上找
  * 其次是toLocalString（），与toString（）相似，根据本地敏感性来将对象转换为字符串
  * valueOf（），转换为原始值返回
  * toJSON（），转换为json数据
  * set类就没有以上任何一种，但该类应当拥有这些方法
* 4、比较方法
  * 比较运算符，＞，＜，==，===
  * equals（）方法，只接收一个实参，如果实参和调用此方法的对象相等则返回true
  * 给set配置equals（）方法需要注意，不能单纯比较值，还需要检测对方是否是集合，that.constructor更加严格，鸭式辩型则更加灵活可以降低严格程度，同时需要注意null与undefined无法通过instanceof检测
  * compareTo（），a.compareTo(b)，小于0说明a<b，与0的关系都可以转换为二者之间的关系
  * 如果比较不合法，equals（）会返回false，但compareTo（）只会抛出异常
  * compareTo（）在面对Range（）时，如果下界相同，就会返回0，判断不完整
* 5、方法借用
  * 一个函数可以赋予两个属性，当做两个方法使用，多个类可以共用同一个函数，可以叫做“多重继承”，但正式称呼是“方法借用”
  * 如果本身没有定义某些方法，可以借用泛型方法
* 6、私有状态
  * 将某些属性或是函数或是方法封装在对象内，只有通过对象的方法才能访问这些状态
  * 可以通过将变量闭包在一个构造函数内来模拟实现私有字段
* 7、构造函数的重载和工厂方法
  * 为了使对象具有更灵活的初始化，可以通过重载这个构造函数让它根据传入不同的参数来执行不同的方法

## 7、子类

* 概念：
  * 类b可以继承自类a，a就被称为父类，b就是子类
  * b的实例继承了a的所有实例，b可以自定义新实例方法，有些方法可以重载a类的同名方法，重载方法可能可以调用a的重载方法，这是“方法链”
  * 子类构造函数B（）有时需要调用父类的构造函数A（），这种称为构造函数链
  * 创建子类的关键在于，采用合适的方法对原型对象进行初始化
  
* 1、定义子类
  * 通过inherit（）函数从父类继承原型对象，重载继承来的constructor属性
  
  * ``` javascript
    B.prototype = inherit(A.prototype);
    B.prototype.constructor = B;
    //这两句很重要，必须要写入
    ```
  
  * 首先需要继承对应原型，然后是设置构造函数为当前自身
  
* 2、构造函数和方法链

  * 有时候希望对父类行为进行修改或者扩充，构造函数和子类的方法就会需要连接或者调用父类的构造函数与方法
  * 在定义子类的基础上，检查是否是null与undefined之后重写对应方法
  * 通过函数包装创建子类的代码，就可以在构造函数和方法链中使用父类的参数，而不是通过定义死的名字来使用

* 3、组合vs子类

  * 组合优于继承
  * 组合代替继承，构造函数格式转换，set依赖实参，并不像子类的方法一样需要定义属性

* 4、类的层次结构与抽象类

  * 在类层次结构中，尽管继承set而来的新类可以继承很多实例方法，但新类和父类的实现完全不同，比起父子关系，更像是同一层次的兄弟关系
  * 抽象类定义了一些辅助方法，但类似foreach（）这样的核心方法没有实现，不需要再实现为某个不相关的子类

