# 第四章 表达式和运算符

## 概念

* 表达式是JavaScript中的一个短语，JavaScript解释器会计算出一个结果。
* 变量名也是一种简单的表达式，它的值就是赋值给变量的值
* 将简单表达式组合成复杂表达式最常用的方法就是运算符。

## 1.原始表达式

* 原始表达式是表达式的最小单位，不包含其他表达式
* 包含的种类：直接量，关键字，变量
* JavaScript代码中如果出现了标识符，JavaScript会把它当做变量去查找它的值，如果不存在，会抛出一个引用错误异常。

## 2.对象和数组的初始化表达式

* 实际上就是一个新创建的对象和数组，有时称作“对象直接量”和“数组直接量”
* 和布尔值直接量等不相同，它们不是原始表达式。
* 对数组初始化表达式进行求值的时候，每一个表达式都会计算一次，每次初始化的值是可以不同的
* 逗号间隔的元素是可以空着不写的，会自动填入undefined
* 对象表达式初始化也会各自计算一次，不必包含数字，对象直接量中的属性名称可以是字符串而不是标识符

## 3.函数定义表达式

* 函数定义表达式可称为“函数直接量”
* 一个典型的函数定义表达式包含关键字function

## 4.属性访问表达式

* 属性访问表达式运算可以得到一个对象属性或者一个数组元素的值。

* 访问定义有两种语法：

  ``` javascript
  expression.identifer
  expression[expression]
  ```

  第一种写法是表达式跟随一个句点和标识符，表达式代表对象，标识符则为访问属性名

  第二种写法是方括号，表达式同样是对象，方括号内是另一个表达式，适用对象数组

* 优先计算“.”和“[”前的表达式，如果得到null和undefined的结果，会抛出类型错误异常。

* .identifer的写法虽然更简单，但仅适用于要访问的属性名已知且合法，不能是保留字或者包含空格的标点符号亦或是一个数字，这一些情况需要用方括号

## 5.调用表达式

* 表达式后跟随一个句点和圆括号，圆括号内放入的是参数列表，可为空，可为多参。或是跟随一个函数。如果引用出错，抛出的是类型错误异常。
* 引用后按顺序将实参数据传给形参，需要返回值，如果形参内容并没传入返回的则为undefined。只有语法错误才会导致程序报错。
* 对于一些严格模式，this并不会指向全局对象，而是将undefined作为this的值

## 6.对象创建表达式

* 创建一个对象并调用一个函数初始化新对象的属性
* 如果不需要传入任何参数的时候，就不需要圆括号
* 计算对象创建表达式的值的时候，和通过{}创建对象的做法一样。一个空的新对象，JavaScript通过传入指定参数并将这个新对象作为this的值来调用一个指定的函数，函数可以用这个this来初始化这个创建的新对象。

## 7.运算符概述

* 主要使用方面：

  * 算术表达式
  * 比较表达式
  * 逻辑表达式
  * 赋值表达式

* 大多数运算符都是标点符号表示的，部分由关键字表示（delete和instanceof）

* 算术运算符也分执行优先级，书本66页

* 1.操作数的个数：

  其实就是指参与运算符的参数个数，大多比较常见的是二元类型

* 2.操作类型与结果类型：

  一些运算符可以作用于任何类型，返回的也是一类特定类型。

* 3.左值：指代出现在赋值运算符左侧的统一数据类型称呼

* 4.运算符的副作用：

  赋值运算符是其中的典型，会改变左侧的属性的类型。delete就像是给属性赋值undefined，实际并非如此。

* 5.运算符优先级：

  * 赋值运算符优先级非常低
  * 乘除优先级大于加减
  * 属性访问表达式和调用表达式优先级比66页所有种类都高
  * typeof也是最高的一批，但在属性访问表达式和调用表达式之后
  * 可以用圆括号强行锁定优先级

* 6.运算符的结合性

  一元操作符，赋值和三元条件运算符都具有从右到左的结合性

* 7.运算顺序

  注意表达式的副作用，特别是自增量。

## 8.算术表达式

* 概念：
  * 主要是算术计算的运算符，还有对操作数的算术操作。
  * 基本运算符：加减乘除求余
  * 求余运算在这里也适用于浮点数
* 1.“+”运算符
  * 作用：两方面。数字加法，字符串连接。
  * 日期对象通过toString转化，其他对象使用valueOf转化
* 2.一元运算符
  * 仅作用于一个操作符，“+”和“-”既是一元也是二元
  * 一元加法（+）：将操作数转换为数字
  * 一元减法（-）：将操作数转换为数字，同时求反
  * 递增（++）：自动增加1，位于操作数前方，返回自增后的数值，位于后方，返回自增前的数值。
  * 递减（--）：其操作数是一个左值，自减，原理同“++”
* 3.位运算符
  * 概念：可以对二进制数据进行更低层级的按位运算。在JavaScript中并不常用，需要对十进制和二进制有一定了解。
  * 与&：对操作数逐位执行布尔与（AND）操作，当两个操作数对应的位都是1，那么这一整个结果才会是1
  * 或|：逐位执行布尔或（OR）操作，当两个操作数对应的位至少有一个是1，整个结果为1
  * 异或^：逐位执行布尔异或XOR操作，两个对应的位有且只有一个是1，整个结果为1
  * 非~：将所有位取反，相当于改变符号并减1
  * 左移<<：将数字转换成2进制数，全部数左移指定位数，因移动而空出的位置用0补足。左移一位，相当于乘以2.
  * 带符号右移>>：将数字转换成2进制数，全体数字右移指定位数，超出右边第一位的数字忽略，最后一位空缺当数字是正数时，补0，是负数时补1。右移一位相当于除以2.
  * 无符号右移>>>：和>>一样，只是都补0。

## 9.关系表达式

* 概念：用于测试两个值之间的关系，总是返回一个布尔值

* 1.相等和不等运算符

  * “=”，“==”，“===”分别是赋值，相等，恒等。
  * 类型不同不恒等，但经过转换可相等
  * 注意null和undefined的不同
  * 0和-0可以划上恒等
  * 对象的相等必须要源于同一个基本对象，而不是属性内容相等
  * String.localCompare()来获取更多相关的信息

* 2.比较运算符

  * “>”,“<”,“>=”,“<=”
  * 满足条件返回true，否则false
  * 最大Infinity，最小-Infinity

* 3.in运算符

  判断左操作数是否存在于右操作数中，in运算符希望左操作数是一个字符串或者可以转换成字符串

* 4.instanceof运算符

  * 左参数是个对象，右操作数标识对象的类。如果左侧是右侧的实例，返回true，否则false。
  * 注意：通过这个运算符判断时，也会包含对父类的检测。

## 10.逻辑模式

* 概念：

  逻辑运算符“&&”，“||”，“！”是对操作数进行布尔算术运算，经常配合关系运算符使用。

* 1.逻辑与（&&）

  * 优先级高于（）和“||”，写的时候甚至可以不用圆括号
  * &&的操作数不一定是布尔值
    * 比如假值：false、null、undefined、0、-0、NaN和“”
    * 有时&&不返回true和false也并非不可能
  * 运算符首先计算左侧的操作数，如果得到假值，就返回左侧的假值，并且不再对右侧进行计算；同理，左侧是真值时，取决于右侧操作数，最后返回的也是右侧操作数的结果作为整体的计算结果。

* 2.逻辑或（||）

  * 常用方法是在一组备选表达式中选出第一个为真值的表达式

* 3.逻辑非（！）

  * 一元运算符，放置在一个单独的操作数前，效果是求反
  * 优先级非常高

## 11.赋值表达式

* JavaScript通过“=”赋值
* “=”的运算符希望左操作数是一个左值：一个变量或者对象属性。右操作数可以是任何值。
* 副作用，赋值完成后，左侧变量或对象属性在赋值后，都可以通过引用左侧变量或对象属性都将得到这个值
* 赋值运算符可以和一元运算符还有位运算符结合使用，op代表了结合用的运算符，结合使用时a op= b，等价于a = a op b

## 12.表达式计算

* JavaScript通过全局函数eval（）来完成解释运行JavaScript源代码组成的字符串

* eval（）虽然是一个函数，但在表达式计算中却是当成运算符来对待了，它存在两个问题

  * 如果函数已经调用了eval（），解释器就不能够进一步优化它
  * 它可以被赋予给其他名字

* 1.eval（）

  * 只有一个参数，如果传入的不是字符串，会直接返回，是字符串就会进行代码编译。编译失败就会返回语法错误的异常，如果成功了则会执行该代码，返回最后一个表达式的值，如果没有值则是undefined。
  * 在最顶层调用eval（），就会作用于全局变量和全局函数，放入eval（）中编译的代码也得语法合理，无意义的语句放入是无意义的，会抛出语法错误异常。

* 2.全局eval（）

  * eval（）有改变局部变量的能力，会与JavaScript优化器起冲突，为了避免这个问题，JavaScript解释器针对调用了eval（）的函数所做的优化不多。
  * ECMAScript3规定了任何解释器都不能给eval（）赋予别名，如果用别的名字引用则会抛出EvalError异常。
  * 实际大多数情况下实现eval（）的别名调用时，其实会把字符串当做顶层的全局代码来执行，可能会定义新的全局变量和全局函数，或者给全局变量赋值，并不能修改主调函数中的局部变量，因此不会影响函数的代码优化
  * ECMAScript是反对使用EvalError的，并且规范了eval（）的行为。“直接的eval”指的是使用非限定的“eval”。
  * IE有一个名叫execScript（）的全局函数来完成全局eval的功能，而且它总是返回的是null

* 3.严格eval（）

  严格模式对eval（）的行为有更多的约束，在此模式下以“use strict”指令开始，可以查询和更改局部变量，但是不能重新定义新的变量或函数

## 13.其他运算符

* 1.条件运算符（？：）
  * JavaScript中唯一一个三元运算符，第一个操作数做布尔值判断，为真返回第二个操作数，否则返回第三个。
* 2.typeof运算符
  * 取得指定操作数的数据类型
* 3.delete运算符
  * 一元操作符，用于删除对象属性或者数组元素
  * delete是用于删除值的，不是用来返回值的
* 4.void运算符
  * 放在操作数之前，操作数可以为任何类型，忽略任何计算结果直接返回undefined
  * 最常用在客户端的URL————javascript：URL中，url中写有副作用的表达式时，就可以用void排除这个隐患。
* 5.逗号运算符
  * 首先计算左操作数，其次是右操作数，最后返回右操作数
  * 总是会计算左侧，但计算结果忽略，只有左侧表达式有副作用，最常用的场景是for

