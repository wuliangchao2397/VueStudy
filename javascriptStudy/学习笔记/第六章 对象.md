# 第六章 对象

## 概念

* 对象是基本类型之一，也是复合值。基本数据结构有很多种类型，散列表（hash），字典（dictionary），关联数组（associative array）。
* 不仅仅是字符串到值的映射，除了可以保持自有的属性，还可以从一个称为原型的对象继承属性。这种原型式继承是JavaScript的核心特征
* JavaScript的对象是动态的，但它们常用来模拟静态对象以及静态语言中的“结构体”（struct）。有时也可做字符串的集合。
* 除了字符串、数字、布尔值、特殊值null和undefined之外，JavaScript中的值都是对象。尽管它们不是对象，但是它们的行为和不可变对象极为相似。
* 常见用法：创建（create）、设置（set）、查找（query）、删除（delete）、测试（test）和枚举（enumerate）。
* 每个属性都有一些相关的值，称为“属性特性”：
  * 可写，表明是否可以设置该属性的值
  * 可枚举，表明是否可以通过for/in循环返回该属性
  * 可配置，表明是否可以删除或修改属性
* 每个对象还有三个相关的对象特性：
  * 对象的原型指向另一个对象，本对象的属性继承自它的原型对象
  * 对象的类是一个标识对象的字符串
  * 对象的扩展标记指明了是否可以向该对象添加新属性
* 对三类对象，两类属性做区分：
  * 内置对象（native object），是由ECMAScript规范定义的对象或类。例如，数组、函数、日期和正则表达式都是内置对象
  * 宿主对象（host object），是由JavaScript解释器所嵌入的宿主环境定义的。客户端JavaScript中表示网页结构的HTMLElement对象均是宿主对象。既然宿主环境定义的方法可以当成普通的JavaScript函数对象，那么宿主对象也可以当成内置对象
  * 自定义对象（user-defined object）是有运行当中的JavaScript代码创建的对象
  * 自有属性（own property）是直接在对象中定义的属性
  * 继承属性（inherited property）是在对象的原型对象中定义的属性

## 1、创建对象

* 概念：通过对象直接量，关键字new和object.create()函数创建对象
* 1、对象直接量
  * 在ECMAScript5中，保留字可以不用引号，而在ECMAScript3中则必须要引号。
  * ECMAScript5中最后一个属性的逗号可以忽略，ECMAScript3中大部分也可以，但IE不行
* 2、通过new创建对象
  * new运算创建并初始化一个新对象。
  * 后跟一个函数调用，这里的函数称为构造函数，用来初始化一个新创建的对象
  * 语言核心中已有原始类型包含内置构造函数，Object（），Array（），Date（），RegExp（）
* 3、原型
  * 每一个JavaScript都从原型这个对象关联，每一个对象都从原型继承属性
  * 所有对象直接量都有同一个原型对象，并可以通过JavaScript代码Object.prototype获得对原型对象的引用。通过Array（）创建的就是Array.prototype（）来获取，其他同理
  * 没有原型的对象不多，Object.prototype（）就是一个，不继承任何属性。
* 4、object.create（）
  * 第一个参数是这个对象的原型
  * 第二个可选参数，是对对象属性进行进一步描述
  * 是一个静态函数，不是给某个对象调用的方法。使用时只需传入所需的原型对象。或通过传入null创建一个没有原型的新对象，但这种方法甚至不会继承基础方法（例如toString（）），意味着“+”运算符无法和它一起使用。
  * 可以通过任意原型创建新对象

## 2、属性的查询和设置

* 概念
  * 查询可以通过（.）和（[]）来获取属性的值，左侧必须是一个返回对象的表达式
    * 对于（.）来说，右侧必须是简单标识符
    * 对于（[]），右侧必须是计算结果的字符串的表达式，这个字符串是表达式的名字
  * 设置数值就如同赋值，将本应存在于右侧的查询语句放在赋值左侧即可
  * 点运算符右侧不可以是保留字
  * 方括号内部严格来说，要是最后可以转换成字符串的值
* 1、作为关联数组的对象
  * JavaScript的对象都是关联数组
  * 点运算必须知道标识符是什么，标识符又必须是静态的
  * 当通过[]方法来访问属性时，我们可以在程序运行过程中修改和创建它，因为只需要结果是一个字符串即可，这可以很灵活的转换成多种多样的字符串。
  * 配合for/in可以做到在不知道对象具体属性名的情况下，依次取到所有可以读取的值
* 2、继承
  * JavaScript对象具有“自有属性”，也有一部分属性从原型对象继承而来
  * 要查询对象o中是否有x，如果o中不存在，就会去o的原型对象查找，如果o的原型对象找不到且还有原型对象，就会继续找下去，依次类推，直到找到x或结果为null。这就形成了一个原型链，通过这个链可以实现属性的继承。
  * 属性赋值首先会检查原型链，是否允许赋值（原型链查找元素和作用域链相似，先来后到）
  * 属性赋值要么失败，要么创建一个属性。
  * 如果o继承自x，那么这时将调用setter方法而不是给o创建一个x
* 3、属性访问错误
  * 属性访问并不是总是设置或返回一个值
  * 查询一个不存在的属性不会报错，会返回undefined
  * 在以下情况给对象设置属性会失败：
    * 对象的属性只读
    * 属性继承的原型对象的属性是只读的
    * 对象中不存在对应的自有属性，对象没有setter方法继承该属性，且对象不可扩展

## 3、删除属性

* delete可以用来删除对象的属性。
* 它的操作数要是一个属性访问表达式，delete只是断开属性和宿主对象的联系，而不会去操作属性中的属性
* delete只能删除自身属性，不能删除继承属性
* delete表达式删除成功或没有任何副作用（删除不存在的属性）甚至delete后跟的不是属性表达式，最后结果也会返回true。
* delete不能删除那些可配置为false的属性，可以删除不可扩展对象的可配置属性
* 严格模式下，delete删除一个不可配置的属性会报类型错误，非严格模式下会返回false
* 非严格模式下，删除全局变量的可配置属性，可以省略对全局变量的引用，直接delete删除指定属性
* 严格模式下，delete后跟随一个非法的操作数，会报一个语法错误，因此必须显示指定对象及其属性

## 4、检测属性

* JavaScript对象可以看做一个属性的集合，我们经常会检测集合中成员的所属关系，即判断某个属性是否存在于某个对象中。
* 可使用in运算符、hasOwnProperty（）和propertyIsEnumerable（）方法来完成这个工作，甚至仅通过属性查询也可以做到。
* in运算左侧是属性名（字符串），右侧是对象，如果存在这个属性，就返回true
* hasOwnProperty（）用于检测给定的名字是否是对象的自由属性，对于继承属性它将返回false
* properIsEnumerable（）是hasOwnProperty（）的增强版，只有检测到是自有属性且这个属性的可枚举性为true时它才返回true
* 有一种场景只能用in运算符，in可以区分不存在的属性和存在但值为undefined的属性
* 注意，“！==”可以区分undefined和null，和“！=”不一样

